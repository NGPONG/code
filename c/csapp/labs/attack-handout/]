* LEVEL1
  * PREQUEST
    1. 本关不需要注入任何新的代码，我们只用保证程序能执行到指定的为止即可
    2. 检查 <test> 函数其语义可大致使用以下代码表示(并不属于完整片段):

       void test() {
         int val;
         val = getbuf();
         printf("No exploit.  Getbuf returned 0x%x\n", val);
       }
        
      本关要求，在 getbuf 返回前能够执行到 <touch1> 函数，而不是打印接下来的 printf
  * SOLVE
    1. see [./ctarget_dump_d] 可知 <touch1> 函数所在地址为 0x4017c0
    2. 既然要求在返 <getbuf> 不能返回原先所在的语义，那么就要求，所输入的字符串需要造成 [buffer overflow] 导致 call 所保存的上一个
    栈帧中的返回地址被破坏，从而使 <getbuf> 执行 ret 指令时会跳转到我们目标的攻击函数中
    3. 查看 <getbuf> 函数逆向实现可知(0x4017a8)，编译期为当前栈帧分配了 0x28 字节，并且这 0x28 字节都为 <Gets> 目标缓冲区所使用，得
    出结论: 我们的攻击字符串需要先向上滑动 0x28 字节，然后再填入目标地址，即: 

      00 00 00 00 00 00 00 00 
      00 00 00 00 00 00 00 00 
      00 00 00 00 00 00 00 00 
      00 00 00 00 00 00 00 00 
      00 00 00 00 00 00 00 00
      c0 17 40 00 00 00 00 00

    4. 这里我们要注意下大小端字节序的问题，see: c0 17 40 00 00 00 00 00
    5. 查看结果: 
      unix> ./hex2rax < exploit.txt > exploit.out
      gdb> r -q < expolit.out


* LEVEL2
  * PREQUEST
    1. 不要使用任何 jmp 或者 call 指令，因为指令要求的目的地址是很难指定的，在这里我们使用 ret 指
    令来代替任意传输的控制的请求
    2. 查看 ./attacklab.pdf/Appendix B 部分去学习如何生成指令的二进制表示以方便接下来的工作

  * SOLVE:
    1. 本关和 LEVE1
