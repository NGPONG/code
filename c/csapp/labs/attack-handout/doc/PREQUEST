FILES:
  * ctarget: involes three code injection attack about buffer overflow.

  * rtarget: involes two ROP(return-oriented programming) attack.

  * hex2rax: Encode each exploit string as a sequence of hex digit pairs separa-
             ted by whitespace, where each hex digit pair represents a byte in 
             the exploit string. The program "hex2raw" converts these strings i-
             nto a sequence of raw bytes, which can then be fed to the target:

                unix> cat exploit.txt | ./hex2raw | ./ctarget

  * cookie.txt: An 8-digit hex code that you will use as a unique identifier in your attacks.


IMPORTANT POINTS:
  * Here is a summary of some important rules regarding valid solutions for this lab. 
  These points will not make much sense when you read this document for the first time. 
  They are presented here as a central reference of rules once you get started.
    * You must do the assignment on a machine that is similar to the one that generated your targets.

    * Your solutions may not use attacks to circumvent the validation code in the programs. Specifically, any address you incorporate into an attack string for use by a ret instruction should be to one of the following destinations:
      * The addresses for functions touch1, touch2, ortouch3.
      * The address of your injected code
      * The address of one of your gadgets from the gadget farm.

    * You may only construct gadgets from filer target with addresses ranging between those for functions start_farm and end_farm.

    * Your exploit strings will typically contain byte values that do not correspond to the ASCII values for printing characters. 
    The program HEX2RAW will enable you to generate these raw strings. 

    * Your exploit string must not contain byte value 0x0a at any intermediate position, since this is the ASCII code for newline (‘\n’).  WhenGetsencounters this byte, it will assume you intended terminate the string.

    * HEX2RAW expects two-digit hex values separated by one or more white spaces.
    So if you want to create a byte with a hex value of 0, you need to write it as 00. 
    To create the word [0xdeadbeef] you should pass 'ef be ad de' to HEX2RAW(note the reversal required for little-endian byte ordering).


EXPOLIT STRINGS:
  * ctarget 和 rtarget 从 [标准输入?] 中获取数据，其内部存在一个函数 getbuf，它的行为类似于 <gets> 的实现，即
  不保证读取字符串的长度是否超出目标缓冲区，当字符长度超出给定的缓冲区长度(长度由 BUFFER_SIZE 所声明的宏定义)
  时，程序将返回错误，否则程序返回 0x1 表示成功.
  * BUFFER_SIZE 的定义依赖于 GCC 的分配策略，要想具体了解它的大小，我们需要逆向拆解代码去查看
  * 引用上一点，我们要保证我的所录入的字符串要足够的 '聪明'，这就是 expolit strings.
  * 保证我们所的 expolit string 包含的字节并不会跟任意一个 ASCII 字符所对应，程序 [HEX2RAW] 将会检测这一行为


CODE INJECTION ATTACKS
  * 最初始的三个阶段，我们的 expolit string 将要攻击 [ctarget]
  * 该程序设置了一种属性使得每次执行都能够保证栈上的地址不存在随机性，简而言之，栈上的数据我们完全可以视为
  可执行代码. 该易受攻击的特性也促使我们能够使用 expolit string 来插入可执行的恶意代码

  * LEVEL 1
    * 本关不需要注入任何新的代码，我们只用保证程序能执行到指定的为止即可
    * 检查 <test> 函数其语义可大致使用以下代码表示(并不属于完整片段):

        void test() {
          int val;
          val = getbuf();
          printf("No exploit.  Getbuf returned 0x%x\n", val);
        }
      
      本关要求，在 getbuf 返回前能够执行到 <touch1> 函数，而不是打印接下来的 printf

