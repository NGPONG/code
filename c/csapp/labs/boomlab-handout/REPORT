* PREREQUEST
  1. 需要弄清楚的函数，see: ./doc/personal/objdumd_d_report.s
    1_1. <skip>
    1_2. <read_line>

* phase_1
  * 该题只需要 si 跟着步骤走，看到一个字符串 cmp 的对比，再读取字符串的值即可得到答案: 
  * Border relations with Canada have never been better.

* phase_2
  * 该题较为复杂，前置条件:
    1. 搞清楚 scanf 在栈中所构造的存储空间
    2. 组织了一个循环语义以读取输入的 6 位数，其中，n 作为数字的偏移，要求满足: %(n + 1) = 2 * %(n)
  * 1 2 4 8 16 32

* phase_3
  * 该题其实就是一个 switch 语义的跳转表，要求:
    1. 找准 sscanf 在当前栈帧中所构造的存储空间(see rsp)
    2. 找准跳转表的具体构造，see: x/8xg 0x402470
    3. switch 语义仅有 8 个跳转，要求第一个输入的字符作为跳转的基准，故第一个输入的字符不能够大于 8
  * 7 327

* phase_4
  * 查看 0x40101f ~ 0x401024 可知，本次出入的文本需要两个字符: 
      * %d %d
    其中，字符 1 存储在:
      * 0x8(%rsp)
      * 调用 func4 之前交由 edi 指向
    字符 2 存储在: 
      * 0xc(%rsp)
      * 调用 func4 之前交由 rcx 指向
  * 查看 func4 源码和 0x401015 ~ 0x401044 部分的代码，并没有利用 rcx 间接对 0xc(%rsp) 进行修改，并且也没有通过直接寻址的方式对该空间进行修改，再查看 0x401051 ~ 0x401061 可知，0xc(%rsp) 恒为 0 是函数退出的必要条件，即: 第二个数必须为 0
  * 查看 0x40102e ~ 0x401033 部分的代码可知，第一个输入的数字必须小于 14
  * 开始分析 func4 的代码，该段函数确定了第一个输入数字的具体值，该函数呈递归调用，分析较为困难，该函数的调用形式呈:
      * func($edx, $esi, $edi); ==> func(14, 0, 0x8(%rsp));
  * 7 0



