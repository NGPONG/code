* PREREQUEST
  1. 需要弄清楚的函数，see: ./doc/personal/objdumd_d_report.s
    1_1. <skip>
    1_2. <read_line>

* phase_1
  * 该题只需要 si 跟着步骤走，看到一个字符串 cmp 的对比，再读取字符串的值即可得到答案: 
  * Border relations with Canada have never been better.

* phase_2
  * 该题较为复杂，前置条件:
    1. 搞清楚 scanf 在栈中所构造的存储空间
    2. 组织了一个循环语义以读取输入的 6 位数，其中，n 作为数字的偏移，要求满足: %(n + 1) = 2 * %(n)
  * 1 2 4 8 16 32

* phase_3
  * 该题其实就是一个 switch 语义的跳转表，要求:
    1. 找准 sscanf 在当前栈帧中所构造的存储空间(see rsp)
    2. 找准跳转表的具体构造，see: x/8xg 0x402470
    3. switch 语义仅有 8 个跳转，要求第一个输入的字符作为跳转的基准，故第一个输入的字符不能够大于 8
  * 7 327

* phase_4
  * 查看 0x40101f ~ 0x401024 可知，本次出入的文本需要两个字符: 
      * %d %d
    其中，字符 1 存储在:
      * 0x8(%rsp)
      * 调用 func4 之前交由 edi 指向
    字符 2 存储在: 
      * 0xc(%rsp)
      * 调用 func4 之前交由 rcx 指向
  * 查看 func4 源码和 0x401015 ~ 0x401044 部分的代码，并没有利用 rcx 间接对 0xc(%rsp) 进行修改，并且也没有通过直接寻址的方式对该空间进行修改，再查看 0x401051 ~ 0x401061 可知，0xc(%rsp) 恒为 0 是函数退出的必要条件，即: 第二个数必须为 0
  * 查看 0x40102e ~ 0x401033 部分的代码可知，第一个输入的数字必须小于 14
  * 开始分析 func4 的代码，该段函数确定了第一个输入数字的具体值，该函数呈递归调用，分析较为困难，该函数的调用形式呈:
      * func($edx, $esi, $edi); ==> func(14, 0, 0x8(%rsp));
  * 7 0

* phase_5
  * 要求输入的字符串长度必须等于 6，see: 0x40107f
  * 查看 0x40108b ~ 0x4010ac，该段是一种循环语义，其循环因子为 6，每次以循环因子为基准呈递增形式读取用户输入的 1byte，并将该数据与 0xf 做逻辑与
    得到的结果再去字符表(0x4024b0)里面检索一字节的数据，并写入栈中(rsp + 0x10)，最后会对比目标字符串(0x40245e)的结果，如果数据相匹配则炸弹解除





1 2 3 4 5 6


1. first number must < 5
2. 




0x603910

0x40111e


for i < 6 {
  字符串 + 1;
  if *(字符串) - 1 < 5 {
    return;
  }
}















