// Generated by the protocol buffer compiler.  DO NOT EDIT!
// source: kwmsgdefine.proto

#ifndef GOOGLE_PROTOBUF_INCLUDED_kwmsgdefine_2eproto
#define GOOGLE_PROTOBUF_INCLUDED_kwmsgdefine_2eproto

#include <limits>
#include <string>

#include <google/protobuf/port_def.inc>
#if PROTOBUF_VERSION < 3017000
#error This file was generated by a newer version of protoc which is
#error incompatible with your Protocol Buffer headers. Please update
#error your headers.
#endif
#if 3017000 < PROTOBUF_MIN_PROTOC_VERSION
#error This file was generated by an older version of protoc which is
#error incompatible with your Protocol Buffer headers. Please
#error regenerate this file with a newer version of protoc.
#endif

#include <google/protobuf/port_undef.inc>
#include <google/protobuf/io/coded_stream.h>
#include <google/protobuf/arena.h>
#include <google/protobuf/arenastring.h>
#include <google/protobuf/generated_message_table_driven.h>
#include <google/protobuf/generated_message_util.h>
#include <google/protobuf/metadata_lite.h>
#include <google/protobuf/generated_message_reflection.h>
#include <google/protobuf/repeated_field.h>  // IWYU pragma: export
#include <google/protobuf/extension_set.h>  // IWYU pragma: export
#include <google/protobuf/generated_enum_reflection.h>
// @@protoc_insertion_point(includes)
#include <google/protobuf/port_def.inc>
#define PROTOBUF_INTERNAL_EXPORT_kwmsgdefine_2eproto
PROTOBUF_NAMESPACE_OPEN
namespace internal {
class AnyMetadata;
}  // namespace internal
PROTOBUF_NAMESPACE_CLOSE

// Internal implementation detail -- do not use these members.
struct TableStruct_kwmsgdefine_2eproto {
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTableField entries[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::AuxiliaryParseTableField aux[]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::ParseTable schema[1]
    PROTOBUF_SECTION_VARIABLE(protodesc_cold);
  static const ::PROTOBUF_NAMESPACE_ID::internal::FieldMetadata field_metadata[];
  static const ::PROTOBUF_NAMESPACE_ID::internal::SerializationTable serialization_table[];
  static const ::PROTOBUF_NAMESPACE_ID::uint32 offsets[];
};
extern const ::PROTOBUF_NAMESPACE_ID::internal::DescriptorTable descriptor_table_kwmsgdefine_2eproto;
PROTOBUF_NAMESPACE_OPEN
PROTOBUF_NAMESPACE_CLOSE
namespace KWMsg {

enum EGameEventCode : int {
  SUCCESS = 0,
  UNKOWN_ERROR = 1,
  CONFIG_ERROR = 2,
  GET_GAME_SERVER_FAIL = 10,
  CONNECT_GAME_SERVER_FAIL = 11,
  SVR_ID_INVALID = 14,
  SVR_ZONEID_INVALID = 15,
  SVR_ZONE_OVERLOAD = 16,
  SVR_MAINTAINING = 17,
  REGISTER_DISABLE = 18,
  RECONNECT_SUCCESS = 19,
  RECONNECT_FAIL = 20,
  NOT_ONLINE = 21,
  LOGIN_INVALID_ACCOUNT_OR_PASSWORD = 30,
  LOGIN_ACCOUNT_NOT_EXIST = 31,
  LOGIN_REGISTER_ACCOUNT_EXIST = 32,
  LOGIN_REGISTER_PASS_CHAR_INVALID = 33,
  LOGIN_REGISTER_PASS_LEN_INVALID = 34,
  KCP_OBJECT_EXIST = 40,
  QUEUE_UP_INVALID_STILL_IN_QUEUE = 50,
  QUEUE_UP_PUSH_INTO_QUEUE = 51,
  QUEUE_UP_CONSUME_TOKEN_FAILD = 52,
  QUEUE_UP_CONSUME_TOKEN_SUCCESS = 53,
  PLAYER_NAME_INVALID_FORMAT = 60,
  PLAYER_NAME_INVALID_WORDS = 61,
  PLAYER_NAME_INVALID_LENGTH = 62,
  PLAYER_NAME_EXIST = 63,
  BTL_MISS_PRIMARY_TARGET = 100,
  BTL_SKILL_SEALED = 150,
  BTL_SKILL_INVALID_CONSUME = 151,
  BTL_SKILL_IN_CD = 152,
  BTL_NOT_AUTO_MODE = 160,
  BTL_TARGET_DEAD = 161,
  BTL_IN_BATTLE = 162,
  STORY_MODULEID_INVALID = 300,
  STORY_CHAPTERSTATUS_INVALID = 301,
  STORY_BATTLE_INVALID = 302,
  EGameEventCode_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EGameEventCode_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EGameEventCode_IsValid(int value);
constexpr EGameEventCode EGameEventCode_MIN = SUCCESS;
constexpr EGameEventCode EGameEventCode_MAX = STORY_BATTLE_INVALID;
constexpr int EGameEventCode_ARRAYSIZE = EGameEventCode_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGameEventCode_descriptor();
template<typename T>
inline const std::string& EGameEventCode_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGameEventCode>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGameEventCode_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGameEventCode_descriptor(), enum_t_value);
}
inline bool EGameEventCode_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGameEventCode* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGameEventCode>(
    EGameEventCode_descriptor(), name, value);
}
enum EGameMsgID : int {
  UNKNOW = 0,
  EVENT_RESULT = 1,
  EVENT_TRANSPORT = 2,
  CLOSE_SOCKET = 3,
  STS_REGISTERED = 4,
  STS_UNREGISTERD = 5,
  STS_REFRESH = 6,
  STS_SERVICE_ROUTE = 7,
  STS_NET_INFO = 8,
  STS_HEART_BEAT = 9,
  STS_SYNC_WORLD_STATE = 10,
  REQ_LOGIN = 200,
  ACK_LOGIN = 201,
  REQ_LOGOUT = 202,
  REQ_CONNECT_WORLD = 210,
  ACK_CONNECT_WORLD = 211,
  REQ_VERIFY_JWT = 212,
  ACK_VERIFY_JWT = 213,
  REQ_KICK_FROM_WORLD = 214,
  ACK_KICK_FROM_WORLD = 215,
  REQ_ENTER_GAME = 220,
  ACK_ENTER_GAME_BEGIN = 221,
  ACK_ENTER_GAME_END = 222,
  REQ_PLAYER_LITE = 223,
  ACK_PLAYER_LITE = 224,
  REQ_UPDATE_ACCOUNT_PLAYER = 225,
  REQ_UPDATE_ACCOUNT_LAST_LOGIN_INFO = 226,
  REQ_LOAD_PLAYER_DATA = 230,
  ACK_LOAD_PLAYER_DATA = 231,
  REQ_SAVE_PLAYER_DATA = 232,
  ACK_SAVE_PLAYER_DATA = 233,
  REQ_LEAVE_GAME = 252,
  ACK_LEAVE_GAME = 253,
  REQ_SWAP_SCENE = 254,
  ACK_SWAP_SCENE_BEGIN = 255,
  ACK_SWAP_SCENE_END = 256,
  REQ_RECONNECT = 260,
  ACK_RECONNECT = 261,
  ACK_OBJECT_ENTRY = 300,
  ACK_OBJECT_LEAVE = 301,
  ACK_OBJECT_PROPERTY_ENTRY = 302,
  ACK_OBJECT_RECORD_ENTRY = 303,
  ACK_PROPERTY_INT = 310,
  ACK_PROPERTY_FLOAT = 311,
  ACK_PROPERTY_STRING = 312,
  ACK_PROPERTY_OBJECT = 313,
  ACK_PROPERTY_VECTOR2 = 314,
  ACK_PROPERTY_VECTOR3 = 315,
  ACK_PROPERTY_CLEAR = 316,
  ACK_ADD_ROW = 320,
  ACK_REMOVE_ROW = 321,
  ACK_SWAP_ROW = 322,
  ACK_RECORD_INT = 323,
  ACK_RECORD_FLOAT = 324,
  ACK_RECORD_STRING = 325,
  ACK_RECORD_OBJECT = 326,
  ACK_RECORD_VECTOR2 = 327,
  ACK_RECORD_VECTOR3 = 328,
  ACK_RECORD_CLEAR = 329,
  ACK_RECORD_SORT = 330,
  ACK_DATA_FINISHED = 340,
  ACK_ONLINE_NOTIFY = 400,
  ACK_OFFLINE_NOTIFY = 401,
  REQ_HEART_BEAT = 410,
  ACK_HEART_BEAT = 411,
  REQ_LAG_TEST = 412,
  ACK_LAG_TEST = 413,
  REQ_SET_GAME_SERVER_STATE = 420,
  ACK_SET_GAME_SERVER_STATE = 421,
  REQ_REFRESH_CONFIG = 422,
  REQ_PUSH_CLIENT_INTO_QUEUEUP = 423,
  ACK_PUSH_CLIENT_INTO_QUEUEUP = 424,
  REQ_QUEUEUP_GET_CUR_WORLD_SUIT_PROXY = 425,
  ACK_QUEUEUP_GET_CUR_WORLD_SUIT_PROXY = 426,
  SYNC_QUEUEUP_REG_STATUS = 427,
  REQ_KICK_CLIENTS_RANDOM = 428,
  REQ_UPDATE_PLAYER_LAST_HEARTBEAT_TS = 429,
  SYNC_QUEUE_UP_USER_CANCEL_OPERATION = 430,
  REQ_RECORD = 1000,
  ACK_RECORD = 1001,
  REQ_CREATE_KCP_OBJECT = 1002,
  ACK_CREATE_KCP_OBJECT = 1003,
  REQ_ESTABLISH_KCP_CONNECTION = 1004,
  ACK_ESTABLISH_KCP_CONNECTION = 1005,
  REQ_KCP_HEART_BEAT = 1006,
  ACK_KCP_HEART_BEAT = 1007,
  REQ_COLLECT_WITCH = 1008,
  ACK_COLLECT_WITCH = 1009,
  REQ_INIT_PLAYER_NAME = 1010,
  ACK_INIT_PLAYER_NAME = 1011,
  REQ_UPDATE_MODULE = 1012,
  ACK_UPDATE_MODULE = 1013,
  REQ_CHAPTER_TIP_OK = 1014,
  ACK_CHAPTER_TIP_OK = 1015,
  ACK_BATTLE_INFO = 1100,
  ACK_BATTLE_PK_INFO = 1101,
  REQ_BATTLE_ACTION = 1102,
  ACK_BATTLE_ACTION = 1103,
  REQ_BATTLE_PULL_MSG = 1104,
  ACK_BATTLE_PULL_MSG = 1105,
  ACK_BATTLE_END_INFO = 1106,
  REQ_BATTLE_TOGGLE_AUTO_MODE = 1107,
  ACK_BATTLE_TOGGLE_AUTO_MODE = 1108,
  REQ_BATTLE_UPDATE_ENTITY_AUTO_MODE = 1109,
  ACK_BATTLE_UPDATE_ENTITY_AUTO_MODE = 1110,
  REQ_BATTLE_SET_PRIO_TARGET = 1111,
  ACK_BATTLE_SET_PRIO_TARGET = 1112,
  REQ_TEST_BATTLE = 1200,
  ACK_TEST_BATTLE = 1201,
  REQ_ENTER_BATTLE = 1202,
  ACK_ENTER_BATTLE = 1203,
  REQ_CMD_EXECUTE = 10000,
  REQ_GM_GET_PLAYER_DATA = 10001,
  ACK_GM_GET_PLAYER_DATA = 10002,
  EGameMsgID_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  EGameMsgID_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool EGameMsgID_IsValid(int value);
constexpr EGameMsgID EGameMsgID_MIN = UNKNOW;
constexpr EGameMsgID EGameMsgID_MAX = ACK_GM_GET_PLAYER_DATA;
constexpr int EGameMsgID_ARRAYSIZE = EGameMsgID_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* EGameMsgID_descriptor();
template<typename T>
inline const std::string& EGameMsgID_Name(T enum_t_value) {
  static_assert(::std::is_same<T, EGameMsgID>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function EGameMsgID_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    EGameMsgID_descriptor(), enum_t_value);
}
inline bool EGameMsgID_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, EGameMsgID* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<EGameMsgID>(
    EGameMsgID_descriptor(), name, value);
}
enum ESceneType : int {
  NORMAL_SCENE = 0,
  SINGLE_CLONE_SCENE = 1,
  MULTI_CLONE_SCENE = 2,
  ESceneType_INT_MIN_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::min(),
  ESceneType_INT_MAX_SENTINEL_DO_NOT_USE_ = std::numeric_limits<::PROTOBUF_NAMESPACE_ID::int32>::max()
};
bool ESceneType_IsValid(int value);
constexpr ESceneType ESceneType_MIN = NORMAL_SCENE;
constexpr ESceneType ESceneType_MAX = MULTI_CLONE_SCENE;
constexpr int ESceneType_ARRAYSIZE = ESceneType_MAX + 1;

const ::PROTOBUF_NAMESPACE_ID::EnumDescriptor* ESceneType_descriptor();
template<typename T>
inline const std::string& ESceneType_Name(T enum_t_value) {
  static_assert(::std::is_same<T, ESceneType>::value ||
    ::std::is_integral<T>::value,
    "Incorrect type passed to function ESceneType_Name.");
  return ::PROTOBUF_NAMESPACE_ID::internal::NameOfEnum(
    ESceneType_descriptor(), enum_t_value);
}
inline bool ESceneType_Parse(
    ::PROTOBUF_NAMESPACE_ID::ConstStringParam name, ESceneType* value) {
  return ::PROTOBUF_NAMESPACE_ID::internal::ParseNamedEnum<ESceneType>(
    ESceneType_descriptor(), name, value);
}
// ===================================================================


// ===================================================================


// ===================================================================

#ifdef __GNUC__
  #pragma GCC diagnostic push
  #pragma GCC diagnostic ignored "-Wstrict-aliasing"
#endif  // __GNUC__
#ifdef __GNUC__
  #pragma GCC diagnostic pop
#endif  // __GNUC__

// @@protoc_insertion_point(namespace_scope)

}  // namespace KWMsg

PROTOBUF_NAMESPACE_OPEN

template <> struct is_proto_enum< ::KWMsg::EGameEventCode> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KWMsg::EGameEventCode>() {
  return ::KWMsg::EGameEventCode_descriptor();
}
template <> struct is_proto_enum< ::KWMsg::EGameMsgID> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KWMsg::EGameMsgID>() {
  return ::KWMsg::EGameMsgID_descriptor();
}
template <> struct is_proto_enum< ::KWMsg::ESceneType> : ::std::true_type {};
template <>
inline const EnumDescriptor* GetEnumDescriptor< ::KWMsg::ESceneType>() {
  return ::KWMsg::ESceneType_descriptor();
}

PROTOBUF_NAMESPACE_CLOSE

// @@protoc_insertion_point(global_scope)

#include <google/protobuf/port_undef.inc>
#endif  // GOOGLE_PROTOBUF_INCLUDED_GOOGLE_PROTOBUF_INCLUDED_kwmsgdefine_2eproto
