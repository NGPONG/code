#include <cstring>
#include <iostream>

class Animal {
public:
  Animal() { }
  Animal(const std::int32_t age) { m_age = age; }

private:
  std::int32_t m_age;
};

class Dog : protected virtual Animal {
public:
  Dog(const std::int32_t val) : m_val_dog(val) { }

private:
  std::int32_t m_val_dog;
};

class Cat : protected virtual Animal {
public:
  Cat(const std::int32_t val) : m_val_cat(val) { }

private:
  std::int32_t m_val_cat;
};

class Hybird : public Dog, public Cat {
public:
  Hybird() : Dog(0x111), Animal(0x333) { }
};

std::int32_t main(void) {
  Hybird hy;

  // 当存在虚继承的类，其内存布局就和之前的不太一样

  // Base b; //
  // 即便是空类，为了保证地址运算于对象唯一性，编译器都至少为其分配一个字节的全部初始化为空的内存数据
  // std::cout << sizeof(b) << std::endl;

  // 虚函数和虚析构警惕使用这个东西
  // std::memset((void *)&last, 0x0, sizeof(Last));

  // 底部派生中如果分别继承了虚基类，则会分别将不同的 vbptr 和对应的 vbtable
  // 放置在该对象所属的内存段内 这些 vbptr 和 vbtable 是虚基类在构造的时候创建的

  // 一个要求是：虚基类必须由最下级派生调用才可以（注意，不是继承链中的任意虚直接派生，抑或是任何非底部派生），保证唯一的作用

  // 但是为什么 Dog 和 Cat 对于其虚基类（虚根基类
  // Animal）的构造函数调用在编译器眼里是无任何效果的，但是我们单纯的去掉不行，因为
  // Animal 中的构造函数覆盖了默认的无参构造

  // 在每个类的首部会存放一个同步的 vbptr 分别指向不同的 vbtable

  return EXIT_SUCCESS;
}
