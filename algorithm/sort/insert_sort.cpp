#include "common.hpp"

// 插入排序
//  * avg  ：O(n^2)
//  * worst: O(n^2) 
//  * best : O(n)
//
// 信息：
// * 插入排序是一种简单的排序算法，通过比较逐个元素以构建最终排序的数组（或列表）。在大型列表上，它比快
// 速排序、堆排序或归并排序等更高级的算法效率低得多。然而，插入排序提供了几个优点：
//  * 简单实现、自适应、在线、就地
//  * 对于（相当）小的数据集来说，就像其他二次（即 O(n^2)）排序算法一样高效。
//  * 在实践中比大多数其他简单的二次算法（如选择排序或冒泡排序）更高效
//
// * 插入排序迭代，每次重复消耗一个输入元素，并增加一个排序好的输出列表。在每次迭代中，插入排序从输入数据
// 中移除一个元素，找到它在排序列表中的位置，并将其插入其中。重复此过程直到没有输入元素剩余。排序通常是在
// 原地进行的，通过迭代数组向上移动，使其后面的排序列表增长。在每个数组位置，它会检查那里的值与排序列表中
// 最大的值（恰好在其旁边，即在前一个检查的数组位置）进行比较。如果较大，则将元素保留在原位并移动到下一个
// 位置。如果较小，则在排序列表中找到正确的位置，将所有较大的值向上移动以腾出空间，并插入到该正确的位置。
//
// * 插入排序与选择排序非常相似。与选择排序一样，在数组中经过 k 次遍历后，前 k 个元素是按顺序排列的。然而，
// 这两种算法之间的根本区别在于插入排序是从当前关键字向后扫描，而选择排序是向前扫描。这导致选择排序将未排序
// 输入的前 k 个元素作为最小的 k 个元素，而插入排序中它们只是输入的前 k 个元素。
//
// * 插入排序的最外层循环可以提供递归的实现。但是者不会使代码变得更短，也不会减少执行时间，但它会将额外的内存消耗
// 从 O(1)增加到 O(N)（在递归的最深层，堆栈包含 N 个对 A 数组的引用，每个引用都伴随着从 N 到 1 的变量 n 的值）。 
//
// * 插入排序相对于选择排序的主要优势在于，选择排序必须始终扫描所有剩余元素，以找到未排序部分列表中的绝对最
// 小元素，而插入排序仅在 k + 1 个元素大于第 k 个元素时需要进行一次比较；当这种情况经常发生时（例如，如果输
// 入数组已经排序或部分排序），插入排序与选择排序相比效率明显更高。平均而言（假设 k + 1 个元素的排名是随机的
// ），插入排序将需要比较和移动前 k 个元素的一半，这意味着插入排序平均将执行大约一半的比较，与选择排序相比。
//
// * 在插入排序的最坏情况下（当输入数组是逆序排序时），插入排序执行的比较次数与选择排序相同。然而，与选择排序
// 相比，插入排序的一个缺点是由于在每次迭代中，将第 k + 1 个元素插入数组的已排序部分需要许多元素交换来移动所有
// 后续元素，而选择排序的每次迭代只需要一个交换。一般来说，插入排序会向数组写入 O(n^2) 次，而选择排序只会写入 O(n) 次。
// 因此，在写入内存的成本显著高于读取的情况下，如 EEPROM 或闪存内存，选择排序可能更可取。
//
// * 尽管一些分治算法（如快速排序和归并排序）在较大的数组上优于插入排序，但非递归排序算法（如插入排序或选择排
// 序）通常在非常小的数组上更快（确切的大小因环境和实现而异，但通常在 7 到 50 个元素之间）。因此，在这些算法的
// 实现中，一种有用的优化是采用混合方法，当数组被划分到较小的大小时使用更简单的算法。

void solution_1(Array &datas) {
  for (size_t i = 1; i < datas.size(); i++) {
    std::int32_t key = datas[i];

    std::int32_t j = i - 1;
    for (; j >= 0 && datas[j] > key; --j) {
      datas[j + 1] = datas[j];
    }
    datas[j + 1] = key;
  }
}

void _solution_2(Array &datas, std::int32_t i = 1) {
  if (i >= datas.size()) {
    return;
  }

  std::int32_t key = datas[i];

  std::int32_t j = i - 1;
  for (; j >= 0 && key < datas[j]; --j) {
    datas[j + 1] = datas[j];
  }

  datas[j + 1] = key;

  _solution_2(datas, ++i);
}
void solution_2(Array &datas) {
  _solution_2(datas);
}

int main(void) {
  solution_test({
    { solution_1, "solution_1" },
    { solution_2, "solution_2" },
  });

  solution_benchmark({
    { solution_1, "solution_1" },
    { solution_2, "solution_2" },
  });

  return EXIT_SUCCESS;
}
