#include <iostream>
#include <string.h>
#include <vector>
#include <algorithm>

//       ---------------------------------------------------------------------
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     +-----------------+     |     |     |     |     |      |      |
//       |     |1: $5            |     |     |     |     |     |      |      |
//       |     +-----------------+     |     |     |     |     |      |      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     |     |     +-----------+     |     |     |     |      |      |
//       |     |     |     |2: $1      |     |     |     |     |      |      |
//       |     |     |     +-----------+     |     |     |     |      |      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       +-----------------------------------+     |     |     |      |      |
//       |3: $8                              |     |     |     |      |      |
//       +-----------------------------------+     |     |     |      |      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     |     |     |     +-----------------+     |     |      |      |
//       |     |     |     |     |4: $4            |     |     |      |      |
//       |     |     |     |     +-----------------+     |     |      |      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     |     |     +-----------------------------+     |      |      |
//       |     |     |     |5: $6                        |     |      |      |
//       |     |     |     +-----------------------------+     |      |      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     |     |     |     |     +-----------------------+      |      |
//       |     |     |     |     |     |6: $3                  |      |      |
//       |     |     |     |     |     +-----------------------+      |      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     |     |     |     |     |     +------------------------+      |
//       |     |     |     |     |     |     |7: $2                   |      |
//       |     |     |     |     |     |     +------------------------+      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     |     |     |     |     |     |     |     +-------------------+
//       |     |     |     |     |     |     |     |     |8: $4              |
//       |     |     |     |     |     |     |     |     +-------------------+
//       |     |     |     |     |     |     |     |     |     |      |      |
// time  0-----1-----2-----3-----4-----5-----6-----7-----8-----9-----10-----11
//
//
// 上面的表格描绘的是一家公司提供给钟点工的薪酬表，它反映了在一天之中，某个时间段下，某个任务所能够提供的报酬是多少，比如
// 说，任务1只能够在 1~4 点钟的时候可以做，该任务做完后的报酬为 $5，并且承接该任务时无法同时进行其它任务，只有当该任务完成
// 后才可以做其它任务，也就是只能再往下看4点钟之后的任务


// 首先分析题意:
//  * 要求，能够找出一天之中 <报酬最多> 的任务安排其 <报酬总数> 是多少
//
// 注意，这里要求得的是 <总报酬> 并不包含该总报酬的组合方式，那么就非常适合使用 DP 来完成
//
// 我们需要分解出子问题，这里我分解出来的子问题则为:
//  * 选择的每一个任务的最优报酬的情况是多少
//
// 我们把每一个任务的最优报酬设为: OPT(i)，首先要明确一点，选择的当前任务其最优报酬的计算肯定不能将当前任务以后的任务算在内的，那么求得最优解则只有两种情况
//  * 我选择该任务: 那么这种情况要在该任务所获得报酬的基础之上，加上终点量和当前任务起始量相同的任务的其 OPT(i)，为了更明确这一定义，我们把这种情况拟定为 OPT(prev(i))
//  * 我们不选择该任务: 那么这种情况也就意味着我们只能以当前任务的上一个任务的最优解作为参考
// 那么将二者对比，即可得到公式: 
//          * 选择: p_i + OPT(prev(i))
//         /
//   OPT(i)
//         \
//          * 不选: OPT(i - 1)
//
// 这里对于选择该任务的情况可能会有点疑问，为什么只是选择终点量距离当前任务其实量最近的任务作为最优解的考量？正如任务 6 的情景，其中任务 1 和任务 2 其实都是可以作为
// 当前任务的叠加参数，但是为什么实际我们只能规定选择任务 2 作为叠加参数呢？反观任务 2 其报酬还更小，这不是不适合吗？
// 存在这种思想主要还是因为没有把我们求得 <子问题最优解> 这句话理解透，还是只是从数据本身和题意去看待本题。我们不妨代入一种自底向上的思路，我们就会发现，虽然任务 2 的
// 实际报酬比任务 1 小，但是这里我们使用的是 <任务2的最优解>，也就意味着任务 2 同样会经过一个 <选择> 的过程，那么我们就可以认为不管是选择任务 1 还是任务 2 的最优解，都
// 是可以作为叠加参数来使用的，因为我们的计算是自底向上来进行的


struct task {
  int begin;
  int end;
  int price;
};

void get_the_max_salary(std::vector<task> &ts) {
  size_t task_count = ts.size() + 1;

  std::vector<int> prev(task_count, 0);

  // 为了针对 [选择] 的情况，我们首先需要计算出 prev 数组，该数组所反馈的情况则为
  // 某个任务编号(数组的下标)下，在该任务开始时间之前、不和当前任务存在重叠关系的
  // 并且距离该任务最近的前一个任务的编号(数组下标所对应的值)
  for (int i = 2; i < task_count; ++i) { // 表示当前检索的任务，从第二个任务开始，因为第一个任务是恒等于0
    for (int j = i - 1; j >= 1; --j) {   // 当前检索的任务向上继续索引的任务
      if (ts[j].end == ts[i].begin) {
        prev[i] = j;                     // 都向后偏移一位进行赋值
        break;
      }
    }
  }

  std::vector<int> opts(task_count, 0);
  // 对于第一个任务，他的上面是没有其他任务可以选择的，所以我们就任务这必定是一种
  // 选择的情况，故直接获取第一个任务的价格即可
  opts[1] = ts[1].price; 
  for (int i = 2; i < task_count; ++i) {
    opts[i] = std::max(opts[i - 1], ts[i].price + opts[prev[i]]);
  }

  // 打印选择的每个任务最大可获取薪酬
  for (auto opt = opts.begin(); opt != opts.end(); ++opt) {
    std::cout << *opt << std::endl;
  }
}

int main(void) {
  std::vector<task> ts = {
    { 0, 0, 0 },
    { 1, 4, 5 },
    { 3, 5, 1 },
    { 0, 6, 8 },
    { 4, 7, 4 },
    { 3, 8, 6 },
    { 5, 9, 3 },
    { 6, 10, 2 },
    { 8, 11, 4 }
  };

  get_the_max_salary(ts);

  return 0;
}
