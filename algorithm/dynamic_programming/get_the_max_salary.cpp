#include <iostream>
#include <string.h>
#include <math.h>
using namespace std;

//       ---------------------------------------------------------------------
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     +-----------------+     |     |     |     |     |      |      |
//       |     |1: $5            |     |     |     |     |     |      |      |
//       |     +-----------------+     |     |     |     |     |      |      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     |     |     +-----------+     |     |     |     |      |      |
//       |     |     |     |2: $1      |     |     |     |     |      |      |
//       |     |     |     +-----------+     |     |     |     |      |      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       +-----------------------------------+     |     |     |      |      |
//       |3: $8                              |     |     |     |      |      |
//       +-----------------------------------+     |     |     |      |      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     |     |     |     +-----------------+     |     |      |      |
//       |     |     |     |     |4: $4            |     |     |      |      |
//       |     |     |     |     +-----------------+     |     |      |      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     |     |     +-----------------------------+     |      |      |
//       |     |     |     |5: $6                        |     |      |      |
//       |     |     |     +-----------------------------+     |      |      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     |     |     |     |     +-----------------------+      |      |
//       |     |     |     |     |     |6: $3                  |      |      |
//       |     |     |     |     |     +-----------------------+      |      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     |     |     |     |     |     +------------------------+      |
//       |     |     |     |     |     |     |7: $2                   |      |
//       |     |     |     |     |     |     +------------------------+      |
//       |     |     |     |     |     |     |     |     |     |      |      |
//       |     |     |     |     |     |     |     |     +-------------------+
//       |     |     |     |     |     |     |     |     |8: $4              |
//       |     |     |     |     |     |     |     |     +-------------------+
//       |     |     |     |     |     |     |     |     |     |      |      |
// time  0-----1-----2-----3-----4-----5-----6-----7-----8-----9-----10-----11
//
//
// 上面的表格描绘的是一家公司提供给钟点工的薪酬表，它反映了在一天之中，某个时间段下，某个任务所能够提供的报酬是多少，比如
// 说，任务1只能够在 1~4 点钟的时候可以做，该任务做完后的报酬为 $5，并且承接该任务时无法同时进行其它任务，只有当该任务完成
// 后才可以做其它任务，也就是只能再往下看4点钟之后的任务
//
// 要求，能够找出一天之中 [报酬最多] 的任务安排其报酬总数是多少

typedef struct task {
  int begin;
  int end;
  int price;
} task_t;

void foo(task_t *ts, int task_count) {
  //        * 选择: p_i + OPT(prev(i))
  //       /
  // OPT(i)
  //       \
  //        * 不选: OPT(i - 1)

  int prev[task_count];
  bzero(prev, sizeof(int) * task_count);

  // 为了针对 [选择] 的情况，我们首先需要计算出 prev 数组，该数组所反馈的情况则为
  // 某个任务编号(数组的下标)下，在该任务开始时间之前、不和当前任务存在重叠关系的
  // 并且距离该任务最近的前一个任务的编号(数组下标所对应的值)
  //
  // 这里有一个问题，对于某个任务选择时的情况，为了获取 OPT，我们应该宏观考虑的是
  // 所有可能发生的情况，而不是仅取符合条件的且离当前任务最近的一个任务作为选择时
  // 的 prev(i)，比如选择了任务 8 后，那么符合条件的任务其实还包括任务 1,2,3,4,5
  // 那么如果选择了任务 8 的时候就有多种组合条件了，甚至可能任务8本身就是最优解
  //
  // 对于上面的问题，考虑到我们的解法是使用的是 自底向上 的方式，也就是从任务编号
  // 1 开始，不断获取最优解，那么意味着任务编号大于1的任务在获取最优解的时候，永远
  // 都会基于一个已经计算过的值来继续向上扩展的，所以这种情况是可以忽略的
  
  prev[0] = 0;
  for (int i = 1; i < task_count; ++i) {
    for (int j = i - 1; j >= 0; --j) {
      if (ts[j].end == ts[i].begin) {
        // 这里的 j 就代表着向下索引的任务编号
        // 这里为什么要 j+1? 因为任务编号是从
        // 11 开始计数的，而数组索引则是从0开
        // 始计数的
        prev[i] = j + 1;
        break;
      }
    }
  }

  int opt[task_count];
  bzero(opt, sizeof(int) * task_count);

  // 对于第一个任务，他的上面是没有其他任务可以选择的，所以我们就任务这必定是一种
  // 选择的情况，故直接获取第一个任务的价格即可
  opt[0] = ts[0].price; 
  for (int i = 1; i < task_count; ++i) {
    if (prev[i] == 0) {
      opt[i] = max(opt[i - 1], ts[i].price);
    } else {
      opt[i] = max(opt[i - 1], ts[i].price + opt[prev[i] - 1]);
    }
  }

  // 打印选择的每个任务最大可获取薪酬
  for (int i = 0; i < task_count; ++i) {
    std::cout << opt[i] << std::endl;
  }
}

int main(void) {
  task_t ts[] = {
    { 1, 4, 5 },
    { 3, 5, 1 },
    { 0, 6, 8 },
    { 4, 7, 4 },
    { 3, 8, 6 },
    { 5, 9, 3 },
    { 6, 10, 2 },
    { 8, 11, 4 }
  };

  foo(ts, 8);

  return 0;
}
